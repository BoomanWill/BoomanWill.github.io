<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Will Stanger</title>
    <link href="https://BoomanWill.github.io/feed.xml" rel="self" />
    <link href="https://BoomanWill.github.io" />
    <updated>2025-04-10T21:36:04+01:00</updated>
    <author>
        <name>Will Stanger</name>
    </author>
    <id>https://BoomanWill.github.io</id>

    <entry>
        <title>Calculating the Area of Fractals with Automata</title>
        <author>
            <name>Will Stanger</name>
        </author>
        <link href="https://BoomanWill.github.io/calculating-the-area-of-fractals-with-automata/"/>
        <id>https://BoomanWill.github.io/calculating-the-area-of-fractals-with-automata/</id>
            <category term="Maths"/>

        <updated>2025-04-10T12:35:38+01:00</updated>
            <summary>
                <![CDATA[
                    A couple of weeks ago I came across this site having watched a livestream by James Munro on twitch where he went through the page&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>A couple of weeks ago I came across <a href="https://penteract.github.io/pythagTree.html">this</a> site having watched a livestream by James Munro on twitch where he went through the page and tried to understand what was going on.</p><p>Basically, a PhD student at MIT used whats called a discrete finite automaton to calculate the area of the pythagoras tree, a fractal which, due to a complicated set of overlapping squares, no one had found the area of. On his livestream, James Munro used a much simpler example which he called the cat fractal to understand the method, which I will attempt to present in writing here.</p><h3 id="the-problem">The Problem</h3>
<p>The problem is to find the area of a fractal called the pythagoras tree. This fractal is formed by first taking a square, then creating two copies of the square, scaling them down by $\frac{1}{\sqrt{2}}$, rotating them by 45 degrees and placing them on the top corners of the original square. This process is then repeated to create the full fractal. Now, in theory, the area of this should be fairly straightforward to calculate by simply using a geometric series but, once we’ve rendered more than a few iterations of the fractal the issue becomes obvious: the squares overlap!</p><figure class="post__image"><img src="https://BoomanWill.github.io/pythag-tree-first.png" alt="The first three iterations of the pythagoras tree"  data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="https://BoomanWill.github.io/pythag-tree.png" alt="The full pythagoras tree"  data-is-external-image="true"></figure><h3 id="the-solution">The Solution</h3>
<h4 id="part-1---automata">Part 1 - Automata</h4>
<p>Automata are perhaps more commonly used in computer science than maths, but the theory of them lies on the border between maths and computer science in “theoretical computer science”. First, we’ll look at <strong>deterministic finite automata (DFA)</strong>. These are machines with a finite number of states, which take as input strings of symbols and either accepts or rejects them by following a series of state transitions. This idea is best represented by a diagram:</p><figure class="post__image"><img loading="lazy" src="https://BoomanWill.github.io/dfa.png" alt="A deterministic finite automaton"  data-is-external-image="true"></figure><p>This example takes a binary string (consisting of just 1s and 0s) as input and only accepts ones with an even number of 0s. The machine has 2 states, state 1 and state 2: state 1 is an accepting state, denoted by the double circle and state 2 is not an accepting state. Depending on which character has just entered the machine into state 1, the state of the machine will either stay at state 1 or change to state 2. For example, if the input string was 10011, we’ll work through the string from right to left:</p><ul>
<li>1: stays at state 1</li>
<li>1: stays at state 1</li>
<li>0: changes to state 2</li>
<li>0: changes to state 1</li>
<li>1: stays at state 1
We have finished at state 1, so we’ll accept that string, which is the behaviour we’d expect as it has an even number of 0s.</li>
</ul>
<p>Let’s break down the name: 
<strong>Deterministic:</strong> what we mean by this is that the series of state transitions is uniquely defined by the input string. On our graph, this means that from each state there is exactly one arrow with each label so we know exactly what will happen to the state of the machine.
<strong>Finite</strong>: this simply means that there are a finite number of states.</p><p>Deterministic finite automata can be used to implement regular expressions and you can read more about them <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">here.</a></p><p>Now we will look at <strong>nondeterministic finite automata (NFA)</strong> which are a generalisation of deterministic finite automata, unsurprisingly, without the requirement of determinism. This means that we could have 2 arrows labelled as 1 coming out of a state, so if we had a 1 going into it, we would’nt be able to know what the next state would be.</p><figure class="post__image"><img src="https://BoomanWill.github.io/nfa.png" alt="A nondeterministic finite automaton"  data-is-external-image="true"></figure><p>In this example, if we had a 1 going into state 1, we would be unable to know whether the next state will be state 1 or state 2 as the state would change nondeterministically.</p><p>Any nondeterministic finite automaton can be converted to a deterministic finite automaton by a <strong>powerset construction</strong>. Using this method, every possible set of states in the nondeterministic automaton becomes one state in the deterministic one. To cut down on the number of states required, we can work through the nondeterministic automaton recording the <em>set</em> of states we could reach with a given input to a given state and then from there, we record the set of states we could reach from any of the states in the previous set.</p><figure class="post__image"><img loading="lazy" src="https://BoomanWill.github.io/powerset.png" alt="Powerset construction"  data-is-external-image="true"></figure><p>This image shows what the result of applying the powerset construction to our previous NFA to create a DFA. Notice that there is only one arrow labelled 1 and one arrow labelled 0 so this is deterministic. For our purposes, we will say that a set of states is accepting if the set contains an accepting state. The reason for this will become clear later.</p><p>Now we have had a look at the basics of automata we will move on to their application to fractals.</p><h4 id="part-2---fractals">Part 2 - Fractals</h4>
<p>One way to measure the area of fractals with some element of self-similarity is to split the fractal up into smaller areas and measure the area of these. First, we will look at a simple right-angled triangle in a square. We’ll try to measure the area of this by breaking the square into 4 smaller squares in the corners.</p><figure class="post__image"><img src="https://BoomanWill.github.io/triangle.png" alt="A triangle broken down into four smaller squares"  data-is-external-image="true"></figure><p>As you can see, in the bottom left we have a full square, in the top right, an empty square and in each of the top left and bottom right a scaled down copy of our original triangle, with 1/4 the area.</p><p>Now lets represent this information in an automaton:</p><figure class="post__image"><img loading="lazy" src="https://BoomanWill.github.io/triangle-automaton.png" alt="The DFA for the triangle"  data-is-external-image="true"></figure><p>This shows that the area of the triangle is the area of a full 
square (1) plus the area of an empty square (0) plus two copies of the area of the triangle again.</p><p>To calculate the area, we start at the triangle state and add up the areas of each corner of the whole square, multiplying by 1/4 to account for the fact that the sub-squares are 1/4 the size :</p><p>$$ A_T = \frac{1}{4}(1) + \frac{1}{4}(0) + 2 \cdot \frac{1}{4}(A_T) $$</p><p>Rearranging gives:</p><p>$$ A_T = \frac{1}{2} $$</p><p>For the triangle example, the automaton is deterministic as there are no overlapping sections. When there is overlap, the automaton we generate is nondeterministic so we need to apply the powerset construction to calculate the area. The example which James Munro used he called the cat fractal. This fractal starts at the triangle from the previous example, makes two copies of it, then scales it down, reflects it and places them in the top left and bottom right corner.</p><figure class="post__image"><img src="https://BoomanWill.github.io/cat-fractal.png" alt="Cat fractal"  data-is-external-image="true"></figure><p>Obviously, there is overlap here so when we make our first automaton, we will have multiple different shapes in each corner so it will be nondeterministic.</p><p>Here is the NFA we get:</p><figure class="post__image"><img loading="lazy" src="https://BoomanWill.github.io/cat-fractal-nfa.png" alt="cat fractal nfa"  data-is-external-image="true"></figure>
            ]]>
        </content>
    </entry>
</feed>
